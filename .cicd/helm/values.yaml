namespace: ""
kind: Deployment

image:
  name: ""
  tag: ""

nameOverride: ""
fullnameOverride: ""

extraLabels: {}

extraVolumes: []
  # -
  #   name: example-name
  #   configMap:
  #     name: configmap-name

extraVolumeMounts: []
  # -
  #   name: example-name
  #   mountPath: /path/in/container

progressDeadlineSeconds: 180
revisionHistoryLimit: 10
minReadySeconds: 0

#  ---------------------------------------------------------------------------------
#  ingress
#  ---------------------------------------------------------------------------------

ingress:
  enabled: false
  className: "nginx"
  annotations:
    cert-manager.io/issuer: letsencrypt
  domain: ""
  tlsSecretName: game-app-tls-cert
  paths:
    -
      path: /
      pathType: ImplementationSpecific

#  ---------------------------------------------------------------------------------
#  requests & limits
#  ---------------------------------------------------------------------------------

resources:
  requests:
    cpu: 100m
    memory: 100Mi
  limits:
    cpu: 300m
    memory: 100Mi

#  ---------------------------------------------------------------------------------
#  service
#  ---------------------------------------------------------------------------------

service:
  type: NodePort
  port: 80
  nodePort: 31000

portName: http

#  ---------------------------------------------------------------------------------
#  nginx config
#  ---------------------------------------------------------------------------------

nginxConfigFileName: nginx.conf
websiteConfigFileName: default.conf.template

nginxConfig: |
  user  nginx;
  worker_processes  auto;

  error_log  /var/log/nginx/error.log notice;
  pid        /var/run/nginx.pid;


  events {
      worker_connections  1024;
  }


  http {
      include       /etc/nginx/mime.types;
      default_type  application/octet-stream;

      log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                        '$status $body_bytes_sent "$http_referer" '
                        '"$http_user_agent" "$http_x_forwarded_for"';

      log_format json_log escape=json '{'
  '"remote_addr": "$remote_addr", ' # client IP, can be modified by ngx_http_realip_module
  '"remote_addr_real": "$realip_remote_addr", ' # real client IP before ngx_http_realip_module replacements
  '"remote_user": "$remote_user", ' # client HTTP username
  '"time_epoch": "$msec", ' # request unixtime in seconds with a milliseconds resolution
  '"time_local": "$time_local", '
  '"time_iso8601": "$time_iso8601", ' # local time in the ISO 8601 standard format
  '"server_name": "$server_name", ' # the name of the vhost serving the request
  '"request_length": "$request_length", ' # request length (including headers and body)
  '"request": "$request", ' # full path no arguments if the request
  '"args": "$args", ' # args
  '"status": $status, ' # response status code
  '"body_bytes_sent": $body_bytes_sent, ' # the number of body bytes exclude headers sent to a client
  '"bytes_sent": "$bytes_sent", ' # the number of bytes sent to a client
  '"http_referer": "$http_referer", ' # HTTP referer
  '"http_user_agent": "$http_user_agent", ' # user agent
  '"upstream_addr": "$upstream_addr", ' # upstream backend server for proxied requests
  '"request_id": "$req_id", ' # the unique request id
  '"upstream_cache_status": "$upstream_cache_status", ' # cache HIT/MISS where applicable
  '"upstream_status": "$upstream_status", '
  '"upstream_connect_time": "$upstream_connect_time", ' # upstream handshake time incl. TLS
  '"upstream_response_time": "$upstream_response_time", ' # time spend receiving upstream body
  '"request_time": $request_time, ' # request processing time in seconds with msec resolution
  '"http_host": "$http_host", ' # the request Host: header
  '"server_protocol": "$server_protocol", ' # request protocol, usually “HTTP/1.0”, “HTTP/1.1”
  '"request_uri": "$request_uri", ' # full original request URI (with arguments)
  '"scheme": "$scheme", ' # http or https
  '"request_method": "$request_method"' # request method
  '}';

      map $http_x_request_id $req_id {
          default   $http_x_request_id;
          ""        $request_id;
      }

      access_log  /var/log/nginx/access.log  json_log;

      sendfile        on;
      #tcp_nopush     on;

      keepalive_timeout  65;

      #gzip  on;

      include /etc/nginx/conf.d/*.conf;
  }

websiteConfig: |
  server {
      listen       80;
      server_name  _;

      location / {
          root   /usr/share/nginx/html;
          index  index.html index.htm;
      }

      #error_page  404              /404.html;

      # redirect server error pages to the static page /50x.html
      #
      error_page   500 502 503 504  /50x.html;
      location = /50x.html {
          root   /usr/share/nginx/html;
      }

      location = /_health {
          return 200 "";
      }
  }



#  ---------------------------------------------------------------------------------
#  scaling
#  ---------------------------------------------------------------------------------

replicaCount: 2
updateStrategy:
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 0
  type: RollingUpdate




autoscaling:
  # hpa:
  #   enabled: false
  #   minReplicas: 2
  #   maxReplicas: 6
  vpa:
    enabled: false
    annotations: {}

    # List of resources that the vertical pod autoscaler can control. Defaults to cpu and memory
    controlledResources: []

    # Define the max allowed resources for the pod
    maxAllowed: {}
    # cpu: 200m
    # memory: 100Mi
    # Define the min allowed resources for the pod
    minAllowed: {}
    # cpu: 200m
    # memory: 100Mi

    updatePolicy:
      updateMode: "Off"

#  ---------------------------------------------------------------------------------
#  affinity rules
#  ---------------------------------------------------------------------------------

nodeSelector: {}

tolerations: []

#  ---------------------------------------------------------------------------------
#  healthchecks
#  ---------------------------------------------------------------------------------

fpmStatusPort: 80
fpmStatusPath: /_health

# Configure the livenessProbe params
# Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbeParams:
  initialDelaySeconds: 0 # wait <initialDelaySeconds> seconds before first probe. Default: 0. Min: 0
  periodSeconds: 10 # make probe every <periodSeconds> seconds. Default 10. Min: 1
  timeoutSeconds: 1 # Number of seconds before probe times out(fails).  Default 1. Min: 1
  successThreshold: 1 # min consecutive successes after failed probe to become successful probe.  Default 1. Min: 1 . Must be 1 for Startup and Liveness
  failureThreshold: 3 # consider check as failed after <failureThreshold> consecutive failes in a row
  terminationGracePeriodSeconds: 60 # (v1.25+) Override pod-level terminationGracePeriodSeconds — grace period for the kubelet to wait before triggering a shut down of the failed container

# # Configure the readinessProbe
# # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
# readinessProbe:
#   exec:
#     command:
#     - cgi-fcgi
#     - -bind
#     - -connect
#     - 127.0.0.1:9001
#   initialDelaySeconds: 0
#   periodSeconds: 5
#   timeoutSeconds: 1
#   successThreshold: 1
#   failureThreshold: 2

terminationGracePeriodSeconds: 30

# Configure the lifecycle
# Ref: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/
lifecycle:
  preStop:
    exec:
      command:
        - sh
        - '-c'
        - sleep 5 && /usr/sbin/nginx -s quit
